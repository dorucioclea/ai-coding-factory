---
description: Test-Driven Development - Write failing tests first, then implement. RED-GREEN-REFACTOR cycle.
globs: ["**/*.cs", "**/*.ts", "**/*.tsx", "**/*.test.ts", "**/*.spec.ts", "**/*Test*.cs"]
alwaysApply: false
---

# TDD Rules for Cursor

## Core Rule
**NO PRODUCTION CODE WITHOUT A FAILING TEST FIRST**

## The Cycle
1. **RED**: Write a failing test that describes desired behavior
2. **GREEN**: Write minimal code to make the test pass
3. **REFACTOR**: Clean up while keeping tests green

## Test Patterns

### .NET (xUnit + FluentAssertions)
```csharp
[Fact]
[Trait("Story", "ACF-XXX")]
public void MethodName_Scenario_ExpectedBehavior()
{
    // Arrange
    var sut = new SystemUnderTest();

    // Act
    var result = sut.DoSomething();

    // Assert
    result.Should().Be(expected);
}
```

### TypeScript (Jest/Vitest)
```typescript
describe('ComponentName', () => {
  it('should behave correctly when condition', () => {
    // Arrange
    const input = createTestData()

    // Act
    const result = functionUnderTest(input)

    // Assert
    expect(result).toBe(expected)
  })
})
```

## Rules
- One behavior per test
- Test name describes what's being tested
- Watch the test fail before implementing
- Write minimal code to pass
- Mocks only when unavoidable
- Coverage >= 80% for business logic
