// FluentValidation Validator Template
// Story: {{StoryId}}
// Generated by Claude Code

using FluentValidation;
using {{Namespace}}.Application.Commands;

namespace {{Namespace}}.Application.Validators;

/// <summary>
/// Validator for <see cref="{{CommandName}}"/>.
/// </summary>
public class {{CommandName}}Validator : AbstractValidator<{{CommandName}}>
{
    public {{CommandName}}Validator()
    {
        // Example validations - customize as needed

        // Required string with max length
        RuleFor(x => x.Name)
            .NotEmpty()
            .WithMessage("Name is required")
            .MaximumLength(100)
            .WithMessage("Name cannot exceed 100 characters");

        // Email validation
        RuleFor(x => x.Email)
            .NotEmpty()
            .WithMessage("Email is required")
            .EmailAddress()
            .WithMessage("Invalid email format");

        // Numeric range
        RuleFor(x => x.Quantity)
            .GreaterThan(0)
            .WithMessage("Quantity must be greater than 0")
            .LessThanOrEqualTo(1000)
            .WithMessage("Quantity cannot exceed 1000");

        // Enum validation
        RuleFor(x => x.Status)
            .IsInEnum()
            .WithMessage("Invalid status value");

        // Conditional validation
        When(x => x.RequiresApproval, () =>
        {
            RuleFor(x => x.ApproverEmail)
                .NotEmpty()
                .WithMessage("Approver email is required when approval is needed")
                .EmailAddress()
                .WithMessage("Invalid approver email format");
        });

        // Collection validation
        RuleFor(x => x.Items)
            .NotEmpty()
            .WithMessage("At least one item is required");

        RuleForEach(x => x.Items)
            .SetValidator(new {{ItemName}}Validator());

        // Custom validation
        RuleFor(x => x)
            .Must(BeValidDateRange)
            .WithMessage("End date must be after start date");

        // Async validation (for database checks)
        // RuleFor(x => x.Code)
        //     .MustAsync(BeUniqueCode)
        //     .WithMessage("Code already exists");
    }

    private bool BeValidDateRange({{CommandName}} command)
    {
        if (!command.StartDate.HasValue || !command.EndDate.HasValue)
            return true;

        return command.EndDate > command.StartDate;
    }

    // Example async validation method
    // private async Task<bool> BeUniqueCode(string code, CancellationToken ct)
    // {
    //     return !await _repository.ExistsAsync(code, ct);
    // }
}

/// <summary>
/// Validator for nested item objects.
/// </summary>
public class {{ItemName}}Validator : AbstractValidator<{{ItemType}}>
{
    public {{ItemName}}Validator()
    {
        RuleFor(x => x.Name)
            .NotEmpty()
            .WithMessage("Item name is required");

        RuleFor(x => x.Price)
            .GreaterThanOrEqualTo(0)
            .WithMessage("Price cannot be negative");
    }
}
