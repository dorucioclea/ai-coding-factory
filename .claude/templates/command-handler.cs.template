// CQRS Command Handler Template
// Story: {{StoryId}}
// Generated by Claude Code

using MediatR;
using Microsoft.Extensions.Logging;
using {{Namespace}}.Domain.Repositories;

namespace {{Namespace}}.Application.Commands.{{Feature}};

// Command
public record {{CommandName}}Command(
    {{CommandProperties}}
) : IRequest<Result<{{ReturnType}}>>;

// Handler
public class {{CommandName}}Handler : IRequestHandler<{{CommandName}}Command, Result<{{ReturnType}}>>
{
    private readonly I{{EntityName}}Repository _repository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly ILogger<{{CommandName}}Handler> _logger;

    public {{CommandName}}Handler(
        I{{EntityName}}Repository repository,
        IUnitOfWork unitOfWork,
        ILogger<{{CommandName}}Handler> logger)
    {
        _repository = repository;
        _unitOfWork = unitOfWork;
        _logger = logger;
    }

    public async Task<Result<{{ReturnType}}>> Handle(
        {{CommandName}}Command request,
        CancellationToken cancellationToken)
    {
        _logger.LogInformation(
            "Handling {{CommandName}} command for {EntityId}",
            request./* EntityId property */);

        try
        {
            // 1. Validate business rules
            // 2. Create/modify domain entity
            // 3. Persist changes
            // 4. Return result

            await _unitOfWork.SaveChangesAsync(cancellationToken);

            return Result.Success(/* return value */);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to handle {{CommandName}} command");
            return Result.Failure<{{ReturnType}}>(Error.FromException(ex));
        }
    }
}

// Validator
public class {{CommandName}}Validator : AbstractValidator<{{CommandName}}Command>
{
    public {{CommandName}}Validator()
    {
        RuleFor(x => x./* Property */)
            .NotEmpty()
            .WithMessage("/* Property */ is required");

        // Add more validation rules
    }
}
