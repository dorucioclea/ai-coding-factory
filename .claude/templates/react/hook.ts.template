// Custom React Hook Template
// Story: {{StoryId}}
// Generated by Claude Code

import { useState, useEffect, useCallback, useMemo } from 'react';

/**
 * Options for the {{hookName}} hook.
 */
export interface Use{{HookName}}Options {
  /** Enable the hook functionality */
  enabled?: boolean;
  /** Callback when state changes */
  onChange?: (value: {{ReturnType}}) => void;
}

/**
 * Return type for the {{hookName}} hook.
 */
export interface Use{{HookName}}Result {
  /** Current value */
  value: {{ReturnType}};
  /** Whether the hook is loading */
  isLoading: boolean;
  /** Any error that occurred */
  error: Error | null;
  /** Reset to initial state */
  reset: () => void;
  /** Update the value */
  setValue: (value: {{ReturnType}}) => void;
}

/**
 * {{hookName}} - {{HookDescription}}
 *
 * @param options - Hook configuration options
 * @returns Hook state and methods
 *
 * @example
 * ```tsx
 * const { value, isLoading, error } = use{{HookName}}({
 *   enabled: true,
 *   onChange: (val) => console.log('Changed:', val),
 * });
 * ```
 */
export function use{{HookName}}(
  options: Use{{HookName}}Options = {}
): Use{{HookName}}Result {
  const { enabled = true, onChange } = options;

  // State
  const [value, setValueInternal] = useState<{{ReturnType}}>({{initialValue}});
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  // Memoized setter that triggers callback
  const setValue = useCallback((newValue: {{ReturnType}}) => {
    setValueInternal(newValue);
    onChange?.(newValue);
  }, [onChange]);

  // Reset function
  const reset = useCallback(() => {
    setValueInternal({{initialValue}});
    setIsLoading(false);
    setError(null);
  }, []);

  // Effect for initialization or subscription
  useEffect(() => {
    if (!enabled) return;

    const initialize = async () => {
      try {
        setIsLoading(true);
        // TODO: Add initialization logic
        // const result = await fetchSomething();
        // setValue(result);
      } catch (err) {
        setError(err instanceof Error ? err : new Error('Unknown error'));
      } finally {
        setIsLoading(false);
      }
    };

    initialize();

    // Cleanup function
    return () => {
      // TODO: Add cleanup logic if needed
    };
  }, [enabled, setValue]);

  // Return memoized result to prevent unnecessary re-renders
  return useMemo(
    () => ({
      value,
      isLoading,
      error,
      reset,
      setValue,
    }),
    [value, isLoading, error, reset, setValue]
  );
}

export default use{{HookName}};
